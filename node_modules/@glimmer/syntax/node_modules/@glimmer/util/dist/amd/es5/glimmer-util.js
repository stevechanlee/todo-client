define('@glimmer/util', ['exports', '@glimmer/env'], function (exports, env) { 'use strict';

  var EMPTY_ARRAY = Object.freeze([]);

  // import Logger from './logger';
  // let alreadyWarned = false;
  function debugAssert(test, msg) {
    // if (!alreadyWarned) {
    //   alreadyWarned = true;
    //   Logger.warn("Don't leave debug assertions on in public builds");
    // }
    if (!test) {
      throw new Error(msg || 'assertion failure');
    }
  }
  function deprecate(desc) {
    console.warn("DEPRECATION: " + desc);
  }

  var GUID = 0;
  function initializeGuid(object) {
    return object._guid = ++GUID;
  }
  function ensureGuid(object) {
    return object._guid || initializeGuid(object);
  }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
  function dict() {
    return Object.create(null);
  }
  function isDict(u) {
    return u !== null && u !== undefined;
  }
  function isObject(u) {
    return typeof u === 'object' && u !== null;
  }
  var DictSet = /*#__PURE__*/function () {
    function DictSet() {
      this.dict = dict();
    }

    var _proto = DictSet.prototype;

    _proto.add = function add(obj) {
      if (typeof obj === 'string') this.dict[obj] = obj;else this.dict[ensureGuid(obj)] = obj;
      return this;
    };

    _proto["delete"] = function _delete(obj) {
      if (typeof obj === 'string') delete this.dict[obj];else if (obj._guid) delete this.dict[obj._guid];
    };

    return DictSet;
  }();
  var StackImpl = /*#__PURE__*/function () {
    function StackImpl() {
      this.stack = [];
      this.current = null;
    }

    var _proto2 = StackImpl.prototype;

    _proto2.push = function push(item) {
      this.current = item;
      this.stack.push(item);
    };

    _proto2.pop = function pop() {
      var item = this.stack.pop();
      var len = this.stack.length;
      this.current = len === 0 ? null : this.stack[len - 1];
      return item === undefined ? null : item;
    };

    _proto2.nth = function nth(from) {
      var len = this.stack.length;
      return len < from ? null : this.stack[len - from];
    };

    _proto2.isEmpty = function isEmpty() {
      return this.stack.length === 0;
    };

    _proto2.toArray = function toArray() {
      return this.stack;
    };

    _createClass(StackImpl, [{
      key: "size",
      get: function get() {
        return this.stack.length;
      }
    }]);

    return StackImpl;
  }();

  function clearElement(parent) {
    var current = parent.firstChild;

    while (current) {
      var next = current.nextSibling;
      parent.removeChild(current);
      current = next;
    }
  }

  var SERIALIZATION_FIRST_NODE_STRING = '%+b:0%';
  function isSerializationFirstNode(node) {
    return node.nodeValue === SERIALIZATION_FIRST_NODE_STRING;
  }

  var ListNode = function ListNode(value) {
    this.next = null;
    this.prev = null;
    this.value = value;
  };
  var LinkedList = /*#__PURE__*/function () {
    function LinkedList() {
      this.clear();
    }

    var _proto = LinkedList.prototype;

    _proto.head = function head() {
      return this._head;
    };

    _proto.tail = function tail() {
      return this._tail;
    };

    _proto.clear = function clear() {
      this._head = this._tail = null;
    };

    _proto.toArray = function toArray() {
      var out = [];
      this.forEachNode(function (n) {
        return out.push(n);
      });
      return out;
    };

    _proto.nextNode = function nextNode(node) {
      return node.next;
    };

    _proto.forEachNode = function forEachNode(callback) {
      var node = this._head;

      while (node !== null) {
        callback(node);
        node = node.next;
      }
    };

    _proto.insertBefore = function insertBefore(node, reference) {
      if (reference === void 0) {
        reference = null;
      }

      if (reference === null) return this.append(node);
      if (reference.prev) reference.prev.next = node;else this._head = node;
      node.prev = reference.prev;
      node.next = reference;
      reference.prev = node;
      return node;
    };

    _proto.append = function append(node) {
      var tail = this._tail;

      if (tail) {
        tail.next = node;
        node.prev = tail;
        node.next = null;
      } else {
        this._head = node;
      }

      return this._tail = node;
    };

    _proto.remove = function remove(node) {
      if (node.prev) node.prev.next = node.next;else this._head = node.next;
      if (node.next) node.next.prev = node.prev;else this._tail = node.prev;
      return node;
    };

    return LinkedList;
  }();
  var ListSlice = /*#__PURE__*/function () {
    function ListSlice(head, tail) {
      this._head = head;
      this._tail = tail;
    }

    var _proto2 = ListSlice.prototype;

    _proto2.forEachNode = function forEachNode(callback) {
      var node = this._head;

      while (node !== null) {
        callback(node);
        node = this.nextNode(node);
      }
    };

    _proto2.head = function head() {
      return this._head;
    };

    _proto2.tail = function tail() {
      return this._tail;
    };

    _proto2.toArray = function toArray() {
      var out = [];
      this.forEachNode(function (n) {
        return out.push(n);
      });
      return out;
    };

    _proto2.nextNode = function nextNode(node) {
      if (node === this._tail) return null;
      return node.next;
    };

    return ListSlice;
  }();
  var EMPTY_SLICE = new ListSlice(null, null);

  var objKeys = Object.keys;
  function assign(obj) {
    for (var i = 1; i < arguments.length; i++) {
      var assignment = arguments[i];
      if (assignment === null || typeof assignment !== 'object') continue;
      var keys = objKeys(assignment);

      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        obj[key] = assignment[key];
      }
    }

    return obj;
  }
  function fillNulls(count) {
    var arr = new Array(count);

    for (var i = 0; i < count; i++) {
      arr[i] = null;
    }

    return arr;
  }
  function values(obj) {
    var vals = [];

    for (var key in obj) {
      vals.push(obj[key]);
    }

    return vals;
  }

  function keys(obj) {
    return Object.keys(obj);
  }
  function unwrap(val) {
    if (val === null || val === undefined) throw new Error("Expected value to be present");
    return val;
  }
  function expect(val, message) {
    if (val === null || val === undefined) throw new Error(message);
    return val;
  }
  function unreachable(message) {
    if (message === void 0) {
      message = 'unreachable';
    }

    return new Error(message);
  }
  function exhausted(value) {
    throw new Error("Exhausted " + value);
  }
  var tuple = function tuple() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return args;
  };
  var symbol = typeof Symbol !== 'undefined' ? Symbol : function (key) {
    return "__" + key + Math.floor(Math.random() * Date.now()) + "__";
  };

  function _createForOfIteratorHelperLoose(o) { var i = 0; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } i = o[Symbol.iterator](); return i.next.bind(i); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function strip(strings) {
    var out = '';

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    for (var i = 0; i < strings.length; i++) {
      var string = strings[i];
      var dynamic = args[i] !== undefined ? String(args[i]) : '';
      out += "" + string + dynamic;
    }

    var lines = out.split('\n');

    while (lines.length && lines[0].match(/^\s*$/)) {
      lines.shift();
    }

    while (lines.length && lines[lines.length - 1].match(/^\s*$/)) {
      lines.pop();
    }

    var min = Infinity;

    for (var _iterator = _createForOfIteratorHelperLoose(lines), _step; !(_step = _iterator()).done;) {
      var line = _step.value;
      var leading = line.match(/^\s*/)[0].length;
      min = Math.min(min, leading);
    }

    var stripped = [];

    for (var _iterator2 = _createForOfIteratorHelperLoose(lines), _step2; !(_step2 = _iterator2()).done;) {
      var _line = _step2.value;
      stripped.push(_line.slice(min));
    }

    return stripped.join('\n');
  }

  /**
   * Encodes a value that can be stored directly instead of being a handle.
   *
   * Immediates use the positive half of 32bits
   *
   * @param value - the value to be encoded.
   */


  function encodeImmediate(value) {
    if (typeof value === 'number') {
      // 1073741827 - (-1) == 1073741828
      // 1073741827 - (-1073741820) == 2147483647
      // positive it stays as is
      // 0 - 1073741823


      return value < 0 ? 1073741827
      /* NEGATIVE_BASE */
      - value : value;
    }

    if (value === false) {
      return 1073741824
      /* FALSE */
      ;
    }

    if (value === true) {
      return 1073741825
      /* TRUE */
      ;
    }

    if (value === null) {
      return 1073741826
      /* NULL */
      ;
    }

    if (value === undefined) {
      return 1073741827
      /* UNDEFINED */
      ;
    }

    return exhausted(value);
  }
  /**
   * Decodes an immediate into its value.
   *
   * @param value - the encoded immediate value
   */

  function decodeImmediate(value) {

    if (value > 1073741823
    /* MAX_INT */
    ) {
        switch (value) {
          case 1073741824
          /* FALSE */
          :
            return false;

          case 1073741825
          /* TRUE */
          :
            return true;

          case 1073741826
          /* NULL */
          :
            return null;

          case 1073741827
          /* UNDEFINED */
          :
            return undefined;

          default:
            // map 1073741828 to 2147483647 to -1 to -1073741820
            // 1073741827 - 1073741828 == -1
            // 1073741827 - 2147483647 == -1073741820
            return 1073741827
            /* NEGATIVE_BASE */
            - value;
        }
      }

    return value;
  }
  /**
   * True if the number can be stored directly or false if it needs a handle.
   *
   * This is used on any number type to see if it can be directly encoded.
   */

  function isSmallInt(num) {
    return isInt(num, -1073741820
    /* MIN_INT */
    , 1073741823
    /* MAX_INT */
    );
  }
  /**
   * True if the encoded int32 operand or encoded stack int32 is a handle.
   */

  function isHandle(encoded) {

    return encoded < 0;
  }
  /**
   * Encodes an index to an operand or stack handle.
   */

  function encodeHandle(index, maxIndex
  /* MAX_INDEX */
  , maxHandle
  /* MAX_HANDLE */
  ) {
    if (maxIndex === void 0) {
      maxIndex = 2147483647;
    }

    if (maxHandle === void 0) {
      maxHandle = -1;
    }

    if (index > maxIndex) {
      throw new Error("index " + index + " overflowed range 0 to " + maxIndex);
    } // -1 - 0 == -1
    // -1 - 1073741823 == -1073741824
    // -1073741825 - 0 == -1073741825
    // -1073741825 - 1073741823 == -2147483648


    return maxHandle - index;
  }
  /**
   * Decodes the index from the specified operand or stack handle.
   */

  function decodeHandle(handle, maxHandle
  /* MAX_HANDLE */
  ) {
    if (maxHandle === void 0) {
      maxHandle = -1;
    }
    // -1 - -1073741824 == 1073741823
    // -1073741825 - -1073741825 == 0
    // -1073741825 - -2147483648 == 1073741823


    return maxHandle - handle;
  }

  function isInt(num, min, max) {
    // this is the same as Math.floor(num) === num
    // also NaN % 1 is NaN and Infinity % 1 is NaN so both should fail
    return num % 1 === 0 && num >= min && num <= max;
  }

  function unwrapHandle(handle) {
    if (typeof handle === 'number') {
      return handle;
    } else {
      var error = handle.errors[0];
      throw new Error("Compile Error: " + error.problem + " @ " + error.span.start + ".." + error.span.end);
    }
  }
  function unwrapTemplate(template) {
    if (template.result === 'error') {
      throw new Error("Compile Error: " + template.problem + " @ " + template.span.start + ".." + template.span.end);
    }

    return template;
  }
  function extractHandle(handle) {
    if (typeof handle === 'number') {
      return handle;
    } else {
      return handle.handle;
    }
  }
  function isOkHandle(handle) {
    return typeof handle === 'number';
  }
  function isErrHandle(handle) {
    return typeof handle === 'number';
  }

  var debugToString;

  if (env.DEBUG) {
    var getFunctionName = function getFunctionName(fn) {
      var functionName = fn.name;

      if (functionName === undefined) {
        var match = Function.prototype.toString.call(fn).match(/function (\w+)\s*\(/);
        functionName = match && match[1] || '';
      }

      return functionName.replace(/^bound /, '');
    };

    var getObjectName = function getObjectName(obj) {
      var name;
      var className;

      if (obj.constructor && obj.constructor !== Object) {
        className = getFunctionName(obj.constructor);
      }

      if ('toString' in obj && obj.toString !== Object.prototype.toString && obj.toString !== Function.prototype.toString) {
        name = obj.toString();
      } // If the class has a decent looking name, and the `toString` is one of the
      // default Ember toStrings, replace the constructor portion of the toString
      // with the class name. We check the length of the class name to prevent doing
      // this when the value is minified.


      if (name && name.match(/<.*:ember\d+>/) && className && className[0] !== '_' && className.length > 2 && className !== 'Class') {
        return name.replace(/<.*:/, "<" + className + ":");
      }

      return name || className;
    };

    var getPrimitiveName = function getPrimitiveName(value) {
      return String(value);
    };

    debugToString = function debugToString(value) {
      if (typeof value === 'function') {
        return getFunctionName(value) || "(unknown function)";
      } else if (typeof value === 'object' && value !== null) {
        return getObjectName(value) || "(unknown object)";
      } else {
        return getPrimitiveName(value);
      }
    };
  }

  var debugToString$1 = debugToString;

  function assertNever(value, desc) {
    if (desc === void 0) {
      desc = 'unexpected unreachable branch';
    }

    console.log('unreachable', value);
    console.trace(desc + " :: " + JSON.stringify(value) + " (" + value + ")");
  }

  exports.DictSet = DictSet;
  exports.EMPTY_ARRAY = EMPTY_ARRAY;
  exports.EMPTY_SLICE = EMPTY_SLICE;
  exports.LinkedList = LinkedList;
  exports.ListNode = ListNode;
  exports.ListSlice = ListSlice;
  exports.SERIALIZATION_FIRST_NODE_STRING = SERIALIZATION_FIRST_NODE_STRING;
  exports.Stack = StackImpl;
  exports.assert = debugAssert;
  exports.assertNever = assertNever;
  exports.assign = assign;
  exports.clearElement = clearElement;
  exports.debugToString = debugToString$1;
  exports.decodeHandle = decodeHandle;
  exports.decodeImmediate = decodeImmediate;
  exports.deprecate = deprecate;
  exports.dict = dict;
  exports.encodeHandle = encodeHandle;
  exports.encodeImmediate = encodeImmediate;
  exports.ensureGuid = ensureGuid;
  exports.exhausted = exhausted;
  exports.expect = expect;
  exports.extractHandle = extractHandle;
  exports.fillNulls = fillNulls;
  exports.initializeGuid = initializeGuid;
  exports.isDict = isDict;
  exports.isErrHandle = isErrHandle;
  exports.isHandle = isHandle;
  exports.isObject = isObject;
  exports.isOkHandle = isOkHandle;
  exports.isSerializationFirstNode = isSerializationFirstNode;
  exports.isSmallInt = isSmallInt;
  exports.keys = keys;
  exports.strip = strip;
  exports.symbol = symbol;
  exports.tuple = tuple;
  exports.unreachable = unreachable;
  exports.unwrap = unwrap;
  exports.unwrapHandle = unwrapHandle;
  exports.unwrapTemplate = unwrapTemplate;
  exports.values = values;

  Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci11dGlsLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9hcnJheS11dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2Fzc2VydC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2d1aWQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9jb2xsZWN0aW9ucy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2RvbS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2lzLXNlcmlhbGl6YXRpb24tZmlyc3Qtbm9kZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2xpc3QtdXRpbHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9vYmplY3QtdXRpbHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9wbGF0Zm9ybS11dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL3N0cmluZy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2ltbWVkaWF0ZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL3RlbXBsYXRlLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvZGVidWctdG8tc3RyaW5nLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgRU1QVFlfQVJSQVk6IGFueVtdID0gT2JqZWN0LmZyZWV6ZShbXSkgYXMgYW55O1xuIiwiLy8gaW1wb3J0IExvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5cbi8vIGxldCBhbHJlYWR5V2FybmVkID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1Z0Fzc2VydCh0ZXN0OiBhbnksIG1zZzogc3RyaW5nKSB7XG4gIC8vIGlmICghYWxyZWFkeVdhcm5lZCkge1xuICAvLyAgIGFscmVhZHlXYXJuZWQgPSB0cnVlO1xuICAvLyAgIExvZ2dlci53YXJuKFwiRG9uJ3QgbGVhdmUgZGVidWcgYXNzZXJ0aW9ucyBvbiBpbiBwdWJsaWMgYnVpbGRzXCIpO1xuICAvLyB9XG5cbiAgaWYgKCF0ZXN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnYXNzZXJ0aW9uIGZhaWx1cmUnKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvZEFzc2VydCgpIHt9XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGUoZGVzYzogc3RyaW5nKSB7XG4gIGNvbnNvbGUud2FybihgREVQUkVDQVRJT046ICR7ZGVzY31gKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVidWdBc3NlcnQ7XG4iLCJsZXQgR1VJRCA9IDA7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGFzR3VpZCB7XG4gIF9ndWlkOiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplR3VpZChvYmplY3Q6IEhhc0d1aWQpOiBudW1iZXIge1xuICByZXR1cm4gKG9iamVjdC5fZ3VpZCA9ICsrR1VJRCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVHdWlkKG9iamVjdDogSGFzR3VpZCk6IG51bWJlciB7XG4gIHJldHVybiBvYmplY3QuX2d1aWQgfHwgaW5pdGlhbGl6ZUd1aWQob2JqZWN0KTtcbn1cbiIsImltcG9ydCB7IEhhc0d1aWQsIGVuc3VyZUd1aWQgfSBmcm9tICcuL2d1aWQnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnLi9wbGF0Zm9ybS11dGlscyc7XG5pbXBvcnQgeyBEaWN0LCBTdGFjayB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNldDxUPiB7XG4gIGFkZCh2YWx1ZTogVCk6IFNldDxUPjtcbiAgZGVsZXRlKHZhbHVlOiBUKTogdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpY3Q8VCA9IHVua25vd24+KCk6IERpY3Q8VD4ge1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGljdDxUPih1OiBUKTogdSBpcyBEaWN0ICYgVCB7XG4gIHJldHVybiB1ICE9PSBudWxsICYmIHUgIT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0PFQ+KHU6IFQpOiB1IGlzIG9iamVjdCAmIFQge1xuICByZXR1cm4gdHlwZW9mIHUgPT09ICdvYmplY3QnICYmIHUgIT09IG51bGw7XG59XG5cbmV4cG9ydCB0eXBlIFNldE1lbWJlciA9IEhhc0d1aWQgfCBzdHJpbmc7XG5cbmV4cG9ydCBjbGFzcyBEaWN0U2V0PFQgZXh0ZW5kcyBTZXRNZW1iZXI+IGltcGxlbWVudHMgU2V0PFQ+IHtcbiAgcHJpdmF0ZSBkaWN0OiBEaWN0PFQ+O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGljdCA9IGRpY3Q8VD4oKTtcbiAgfVxuXG4gIGFkZChvYmo6IFQpOiBTZXQ8VD4ge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykgdGhpcy5kaWN0W29iaiBhcyBhbnldID0gb2JqO1xuICAgIGVsc2UgdGhpcy5kaWN0W2Vuc3VyZUd1aWQob2JqIGFzIGFueSldID0gb2JqO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVsZXRlKG9iajogVCkge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykgZGVsZXRlIHRoaXMuZGljdFtvYmogYXMgYW55XTtcbiAgICBlbHNlIGlmICgob2JqIGFzIGFueSkuX2d1aWQpIGRlbGV0ZSB0aGlzLmRpY3RbKG9iaiBhcyBhbnkpLl9ndWlkXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3RhY2tJbXBsPFQ+IGltcGxlbWVudHMgU3RhY2s8VD4ge1xuICBwcml2YXRlIHN0YWNrOiBUW10gPSBbXTtcbiAgcHVibGljIGN1cnJlbnQ6IE9wdGlvbjxUPiA9IG51bGw7XG5cbiAgcHVibGljIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgfVxuXG4gIHB1c2goaXRlbTogVCkge1xuICAgIHRoaXMuY3VycmVudCA9IGl0ZW07XG4gICAgdGhpcy5zdGFjay5wdXNoKGl0ZW0pO1xuICB9XG5cbiAgcG9wKCk6IE9wdGlvbjxUPiB7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIGxldCBsZW4gPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB0aGlzLmN1cnJlbnQgPSBsZW4gPT09IDAgPyBudWxsIDogdGhpcy5zdGFja1tsZW4gLSAxXTtcblxuICAgIHJldHVybiBpdGVtID09PSB1bmRlZmluZWQgPyBudWxsIDogaXRlbTtcbiAgfVxuXG4gIG50aChmcm9tOiBudW1iZXIpOiBPcHRpb248VD4ge1xuICAgIGxldCBsZW4gPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICByZXR1cm4gbGVuIDwgZnJvbSA/IG51bGwgOiB0aGlzLnN0YWNrW2xlbiAtIGZyb21dO1xuICB9XG5cbiAgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjay5sZW5ndGggPT09IDA7XG4gIH1cblxuICB0b0FycmF5KCk6IFRbXSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2s7XG4gIH1cbn1cbiIsImltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgU2ltcGxlRWxlbWVudCwgU2ltcGxlTm9kZSB9IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckVsZW1lbnQocGFyZW50OiBTaW1wbGVFbGVtZW50KSB7XG4gIGxldCBjdXJyZW50OiBPcHRpb248U2ltcGxlTm9kZT4gPSBwYXJlbnQuZmlyc3RDaGlsZDtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIGxldCBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY3VycmVudCk7XG4gICAgY3VycmVudCA9IG5leHQ7XG4gIH1cbn1cbiIsImltcG9ydCB7IFNpbXBsZU5vZGUgfSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuXG5leHBvcnQgY29uc3QgU0VSSUFMSVpBVElPTl9GSVJTVF9OT0RFX1NUUklORyA9ICclK2I6MCUnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTZXJpYWxpemF0aW9uRmlyc3ROb2RlKG5vZGU6IFNpbXBsZU5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIG5vZGUubm9kZVZhbHVlID09PSBTRVJJQUxJWkFUSU9OX0ZJUlNUX05PREVfU1RSSU5HO1xufVxuIiwiaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnLi9wbGF0Zm9ybS11dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlua2VkTGlzdE5vZGUge1xuICBuZXh0OiBPcHRpb248TGlua2VkTGlzdE5vZGU+O1xuICBwcmV2OiBPcHRpb248TGlua2VkTGlzdE5vZGU+O1xufVxuXG5leHBvcnQgY2xhc3MgTGlzdE5vZGU8VD4gaW1wbGVtZW50cyBMaW5rZWRMaXN0Tm9kZSB7XG4gIHB1YmxpYyBuZXh0OiBPcHRpb248TGlzdE5vZGU8VD4+ID0gbnVsbDtcbiAgcHVibGljIHByZXY6IE9wdGlvbjxMaXN0Tm9kZTxUPj4gPSBudWxsO1xuICBwdWJsaWMgdmFsdWU6IFQ7XG5cbiAgY29uc3RydWN0b3IodmFsdWU6IFQpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbn1cblxuLy8gd2UgYXJlIHVuYWJsZSB0byBleHByZXNzIHRoZSBjb25zdHJhaW50IHRoYXQgVCdzIC5wcmV2IGFuZCAubmV4dCBhcmVcbi8vIHRoZW1zZWx2ZXMgVC4gSG93ZXZlciwgaXQgd2lsbCBhbHdheXMgYmUgdHJ1ZSwgc28gdHJ1c3QgdXMuXG50eXBlIHRydXN0ID0gYW55O1xuXG5leHBvcnQgY2xhc3MgTGlua2VkTGlzdDxUIGV4dGVuZHMgTGlua2VkTGlzdE5vZGU+IGltcGxlbWVudHMgU2xpY2U8VD4ge1xuICBwcml2YXRlIF9oZWFkITogT3B0aW9uPFQ+O1xuICBwcml2YXRlIF90YWlsITogT3B0aW9uPFQ+O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgfVxuXG4gIGhlYWQoKTogT3B0aW9uPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5faGVhZDtcbiAgfVxuXG4gIHRhaWwoKTogT3B0aW9uPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5fdGFpbDtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gbnVsbDtcbiAgfVxuXG4gIHRvQXJyYXkoKTogVFtdIHtcbiAgICBsZXQgb3V0OiBUW10gPSBbXTtcbiAgICB0aGlzLmZvckVhY2hOb2RlKG4gPT4gb3V0LnB1c2gobikpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBuZXh0Tm9kZShub2RlOiBUKTogVCB7XG4gICAgcmV0dXJuIG5vZGUubmV4dCBhcyB0cnVzdDtcbiAgfVxuXG4gIGZvckVhY2hOb2RlKGNhbGxiYWNrOiAobm9kZTogVCkgPT4gdm9pZCkge1xuICAgIGxldCBub2RlID0gdGhpcy5faGVhZDtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhub2RlIGFzIHRydXN0KTtcbiAgICAgIG5vZGUgPSBub2RlLm5leHQgYXMgdHJ1c3Q7XG4gICAgfVxuICB9XG5cbiAgaW5zZXJ0QmVmb3JlKG5vZGU6IFQsIHJlZmVyZW5jZTogT3B0aW9uPFQ+ID0gbnVsbCk6IFQge1xuICAgIGlmIChyZWZlcmVuY2UgPT09IG51bGwpIHJldHVybiB0aGlzLmFwcGVuZChub2RlKTtcblxuICAgIGlmIChyZWZlcmVuY2UucHJldikgcmVmZXJlbmNlLnByZXYubmV4dCA9IG5vZGU7XG4gICAgZWxzZSB0aGlzLl9oZWFkID0gbm9kZTtcblxuICAgIG5vZGUucHJldiA9IHJlZmVyZW5jZS5wcmV2O1xuICAgIG5vZGUubmV4dCA9IHJlZmVyZW5jZTtcbiAgICByZWZlcmVuY2UucHJldiA9IG5vZGU7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGFwcGVuZChub2RlOiBUKTogVCB7XG4gICAgbGV0IHRhaWwgPSB0aGlzLl90YWlsO1xuXG4gICAgaWYgKHRhaWwpIHtcbiAgICAgIHRhaWwubmV4dCA9IG5vZGU7XG4gICAgICBub2RlLnByZXYgPSB0YWlsO1xuICAgICAgbm9kZS5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGVhZCA9IG5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl90YWlsID0gbm9kZSk7XG4gIH1cblxuICByZW1vdmUobm9kZTogVCk6IFQge1xuICAgIGlmIChub2RlLnByZXYpIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgIGVsc2UgdGhpcy5faGVhZCA9IG5vZGUubmV4dCBhcyB0cnVzdDtcblxuICAgIGlmIChub2RlLm5leHQpIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2O1xuICAgIGVsc2UgdGhpcy5fdGFpbCA9IG5vZGUucHJldiBhcyB0cnVzdDtcblxuICAgIHJldHVybiBub2RlO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpY2U8VCBleHRlbmRzIExpbmtlZExpc3ROb2RlPiB7XG4gIGhlYWQoKTogT3B0aW9uPFQ+O1xuICB0YWlsKCk6IE9wdGlvbjxUPjtcbiAgbmV4dE5vZGUobm9kZTogVCk6IE9wdGlvbjxUPjtcbiAgZm9yRWFjaE5vZGUoY2FsbGJhY2s6IChub2RlOiBUKSA9PiB2b2lkKTogdm9pZDtcbiAgdG9BcnJheSgpOiBUW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xvbmVhYmxlTGlzdE5vZGUgZXh0ZW5kcyBMaW5rZWRMaXN0Tm9kZSB7XG4gIGNsb25lKCk6IHRoaXM7XG59XG5cbmV4cG9ydCBjbGFzcyBMaXN0U2xpY2U8VCBleHRlbmRzIExpbmtlZExpc3ROb2RlPiBpbXBsZW1lbnRzIFNsaWNlPFQ+IHtcbiAgcHJpdmF0ZSBfaGVhZDogT3B0aW9uPFQ+O1xuICBwcml2YXRlIF90YWlsOiBPcHRpb248VD47XG5cbiAgY29uc3RydWN0b3IoaGVhZDogT3B0aW9uPFQ+LCB0YWlsOiBPcHRpb248VD4pIHtcbiAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICB0aGlzLl90YWlsID0gdGFpbDtcbiAgfVxuXG4gIGZvckVhY2hOb2RlKGNhbGxiYWNrOiAobm9kZTogVCkgPT4gdm9pZCkge1xuICAgIGxldCBub2RlID0gdGhpcy5faGVhZDtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgIG5vZGUgPSB0aGlzLm5leHROb2RlKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGhlYWQoKTogT3B0aW9uPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5faGVhZDtcbiAgfVxuXG4gIHRhaWwoKTogT3B0aW9uPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5fdGFpbDtcbiAgfVxuXG4gIHRvQXJyYXkoKTogVFtdIHtcbiAgICBsZXQgb3V0OiBUW10gPSBbXTtcbiAgICB0aGlzLmZvckVhY2hOb2RlKG4gPT4gb3V0LnB1c2gobikpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBuZXh0Tm9kZShub2RlOiBUKTogT3B0aW9uPFQ+IHtcbiAgICBpZiAobm9kZSA9PT0gdGhpcy5fdGFpbCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIG5vZGUubmV4dCBhcyBUO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9TTElDRSA9IG5ldyBMaXN0U2xpY2UobnVsbCwgbnVsbCk7XG4iLCJjb25zdCB7IGtleXM6IG9iaktleXMgfSA9IE9iamVjdDtcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxULCBVPihvYmo6IFQsIGFzc2lnbm1lbnRzOiBVKTogVCAmIFU7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFUsIFY+KG9iajogVCwgYTogVSwgYjogVik6IFQgJiBVICYgVjtcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248VCwgVSwgViwgVz4ob2JqOiBULCBhOiBVLCBiOiBWLCBjOiBXKTogVCAmIFUgJiBWICYgVztcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248VCwgVSwgViwgVywgWD4ob2JqOiBULCBhOiBVLCBiOiBWLCBjOiBXLCBkOiBYKTogVCAmIFUgJiBWICYgVyAmIFg7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFUsIFYsIFcsIFgsIFk+KFxuICBvYmo6IFQsXG4gIGE6IFUsXG4gIGI6IFYsXG4gIGM6IFcsXG4gIGQ6IFgsXG4gIGU6IFlcbik6IFQgJiBVICYgViAmIFcgJiBYICYgWTtcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248VCwgVSwgViwgVywgWCwgWSwgWj4oXG4gIG9iajogVCxcbiAgYTogVSxcbiAgYjogVixcbiAgYzogVyxcbiAgZDogWCxcbiAgZTogWSxcbiAgZjogWlxuKTogVCAmIFUgJiBWICYgVyAmIFggJiBZICYgWjtcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0OiBhbnksIC4uLmFyZ3M6IGFueVtdKTogYW55O1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmo6IGFueSkge1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBhc3NpZ25tZW50ID0gYXJndW1lbnRzW2ldO1xuICAgIGlmIChhc3NpZ25tZW50ID09PSBudWxsIHx8IHR5cGVvZiBhc3NpZ25tZW50ICE9PSAnb2JqZWN0JykgY29udGludWU7XG4gICAgbGV0IGtleXMgPSBvYmpLZXlzKGFzc2lnbm1lbnQpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgbGV0IGtleSA9IGtleXNbal07XG4gICAgICBvYmpba2V5XSA9IGFzc2lnbm1lbnRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGxOdWxsczxUPihjb3VudDogbnVtYmVyKTogVFtdIHtcbiAgbGV0IGFyciA9IG5ldyBBcnJheShjb3VudCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgYXJyW2ldID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZXM8VD4ob2JqOiB7IFtzOiBzdHJpbmddOiBUIH0pOiBUW10ge1xuICBjb25zdCB2YWxzID0gW107XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHZhbHMucHVzaChvYmpba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHZhbHM7XG59XG4iLCJleHBvcnQgdHlwZSBPcHRpb248VD4gPSBUIHwgbnVsbDtcbmV4cG9ydCB0eXBlIE1heWJlPFQ+ID0gT3B0aW9uPFQ+IHwgdW5kZWZpbmVkIHwgdm9pZDtcblxuZXhwb3J0IHR5cGUgRmFjdG9yeTxUPiA9IG5ldyAoLi4uYXJnczogdW5rbm93bltdKSA9PiBUO1xuXG5leHBvcnQgZnVuY3Rpb24ga2V5czxUPihvYmo6IFQpOiBBcnJheTxrZXlvZiBUPiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopIGFzIEFycmF5PGtleW9mIFQ+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwPFQ+KHZhbDogTWF5YmU8VD4pOiBUIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB2YWx1ZSB0byBiZSBwcmVzZW50YCk7XG4gIHJldHVybiB2YWwgYXMgVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGVjdDxUPih2YWw6IE1heWJlPFQ+LCBtZXNzYWdlOiBzdHJpbmcpOiBUIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gdmFsIGFzIFQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnJlYWNoYWJsZShtZXNzYWdlID0gJ3VucmVhY2hhYmxlJyk6IEVycm9yIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4aGF1c3RlZCh2YWx1ZTogbmV2ZXIpOiBuZXZlciB7XG4gIHRocm93IG5ldyBFcnJvcihgRXhoYXVzdGVkICR7dmFsdWV9YCk7XG59XG5cbmV4cG9ydCB0eXBlIExpdCA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCB1bmRlZmluZWQgfCBudWxsIHwgdm9pZCB8IHt9O1xuXG5leHBvcnQgY29uc3QgdHVwbGUgPSA8VCBleHRlbmRzIExpdFtdPiguLi5hcmdzOiBUKSA9PiBhcmdzO1xuXG5leHBvcnQgY29uc3Qgc3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IFN5bWJvbFxuICAgIDogKGtleTogc3RyaW5nKSA9PiBgX18ke2tleX0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIERhdGUubm93KCkpfV9fYCBhcyBhbnk7XG4iLCJleHBvcnQgZnVuY3Rpb24gc3RyaXAoc3RyaW5nczogVGVtcGxhdGVTdHJpbmdzQXJyYXksIC4uLmFyZ3M6IHVua25vd25bXSkge1xuICBsZXQgb3V0ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBzdHJpbmcgPSBzdHJpbmdzW2ldO1xuICAgIGxldCBkeW5hbWljID0gYXJnc1tpXSAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKGFyZ3NbaV0pIDogJyc7XG5cbiAgICBvdXQgKz0gYCR7c3RyaW5nfSR7ZHluYW1pY31gO1xuICB9XG5cbiAgbGV0IGxpbmVzID0gb3V0LnNwbGl0KCdcXG4nKTtcblxuICB3aGlsZSAobGluZXMubGVuZ3RoICYmIGxpbmVzWzBdLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgIGxpbmVzLnNoaWZ0KCk7XG4gIH1cblxuICB3aGlsZSAobGluZXMubGVuZ3RoICYmIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgIGxpbmVzLnBvcCgpO1xuICB9XG5cbiAgbGV0IG1pbiA9IEluZmluaXR5O1xuXG4gIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBsZXQgbGVhZGluZyA9IGxpbmUubWF0Y2goL15cXHMqLykhWzBdLmxlbmd0aDtcblxuICAgIG1pbiA9IE1hdGgubWluKG1pbiwgbGVhZGluZyk7XG4gIH1cblxuICBsZXQgc3RyaXBwZWQgPSBbXTtcblxuICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgc3RyaXBwZWQucHVzaChsaW5lLnNsaWNlKG1pbikpO1xuICB9XG5cbiAgcmV0dXJuIHN0cmlwcGVkLmpvaW4oJ1xcbicpO1xufVxuIiwiaW1wb3J0IHsgZXhoYXVzdGVkIH0gZnJvbSAnLi9wbGF0Zm9ybS11dGlscyc7XG5pbXBvcnQgeyBMT0NBTF9ERUJVRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcblxubGV0IGNoZWNrSW50OiB1bmRlZmluZWQgfCAoKG51bTogbnVtYmVyLCBtaW4/OiBudW1iZXIsIG1heD86IG51bWJlcikgPT4gdm9pZCk7XG5cbmlmIChMT0NBTF9ERUJVRykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyLHZhcnMtb24tdG9wXG4gIGNoZWNrSW50ID0gKG51bTogbnVtYmVyLCBtaW4gPSAtMjE0NzQ4MzY0OCwgbWF4ID0gMjE0NzQ4MzY0NykgPT4ge1xuICAgIGlmICghaXNJbnQobnVtLCBtaW4sIG1heCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHtudW19IHRvIGJlIGFuIGludGVnZXIgYmV0d2VlbiAke21pbn0gdG8gJHttYXh9YCk7XG4gICAgfVxuICB9O1xufVxuXG4vKlxuRW5jb2Rpbmcgbm90ZXNcblxuZmlyc3RcbjIgYml0cyAgICBzdGFydCAgICAgICAgZW5kXG4wIDEgICAgICAgMTA3Mzc0MTgyNCAgIDIxNDc0ODM2NDcgICBkaXJlY3QgbmVnYXRpdmUgb3IgYm9vbGVhbiBvciBudWxsIG9yIHVuZGVmaW5lZFxuMCAwICAgICAgIDAgICAgICAgICAgICAxMDczNzQxODIzICAgZGlyZWN0IHBvc2l0aXZlXG4xIDEgICAgICAgLTEgICAgICAgICAgIC0xMDczNzQxODI0ICBzdHJpbmcgaW5kZXhcbjEgMCAgICAgICAtMTA3Mzc0MTgyNSAgLTIxNDc0ODM2NDggIG51bWJlciBpbmRleFxuXG5TaW5jZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24gYml0IHRoZW5cblxuZW5jb2RlZCA+PSAwICBpcyBhbGwgZGlyZWN0bHkgZW5jb2RlZCB2YWx1ZXNcbmVuY29kZWQgPCAwICBpcyBhbGwgaW5kaXJlY3QgZW5jb2RlZCB2YWx1ZXMgKGVuY29kZWQgaW5kZXhlcylcblxuRm9yIGRpcmVjdGx5IGVuY29kZWQgdmFsdWVzXG5lbmNvZGVkICAgICAgZGVjb2RlZFxuMCAgICAgICAgICAgIDBcbi4uLiAgICAgICAgICAuLi5cbjEwNzM3NDE4MjMgICAxMDczNzQxODIzXG4xMDczNzQxODI0ICAgZmFsc2VcbjEwNzM3NDE4MjUgICB0cnVlXG4xMDczNzQxODI2ICAgbnVsbFxuMTA3Mzc0MTgyNyAgIHVuZGVmaW5lZFxuMTA3Mzc0MTgyOCAgIC0xXG4uLi4gICAgICAgICAgLi4uXG4yMTQ3NDgzNjQ3ICAgLTEwNzM3NDE4MjBcblxuZm9yIHN0YWNrIGhhbmRsZXNcbndlIG1hcCBqcyBpbmRleCAwIHRvIDIxNDc0ODM2NDcgb250byAtMSB0byAtMjE0NzQ4MzY0OFxuXG5mb3IgY29uc3RhbnQgaGFuZGxlc1xud2UgbWFwIHN0cmluZyBpbmRleCAwIHRvIDEwNzM3NDE4MjMgb250byAtMSB0byAtMTA3Mzc0MTgyNFxud2UgbWFwIG51bWJlciBpbmRleCAwIHRvIDEwNzM3NDE4MjMgb250byAtMTA3Mzc0MTgyNSB0byAtMjE0NzQ4MzY0OFxuKi9cblxuLyoqXG4gKiBJbW1lZGlhdGVzIHVzZSB0aGUgcG9zaXRpdmUgaGFsZiBvZiAzMiBiaXRzIDAgdGhyb3VnaCAyMTQ3NDgzNjQ3ICgweDdmZmZmZmZmKVxuICogbGVhdmluZyB0aGUgbmVnYXRpdmUgaGFsZiBmb3IgaGFuZGxlcyAtMSB0aHJvdWdoIC0yMTQ3NDgzNjQ4LlxuICovXG5leHBvcnQgY29uc3QgZW51bSBJbW1lZGlhdGVDb25zdGFudHMge1xuICAvKipcbiAgICogMzEgYml0cyBjYW4gZW5jb2RlIDJeMzEgdmFsdWVzXG4gICAqL1xuICBJTU1FRElBVEVfTEVOR1RIID0gMiAqKiAzMSxcblxuICAvKipcbiAgICogTWluIGVuY29kZWQgaW1tZWRpYXRlIGlzIG1pbiBwb3NpdGl2ZVxuICAgKi9cbiAgTUlOX0lNTUVESUFURSA9IDAsXG5cbiAgLyoqXG4gICAqIE1heCBlbmNvZGVkIGltbWVkaWF0ZSBpcyB0aGUgbWF4IHBvc2l0aXZlIDMyIGJpdCBzaWduZWQgaW50XG4gICAqL1xuICBNQVhfSU1NRURJQVRFID0gSU1NRURJQVRFX0xFTkdUSCAtIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBlbmNvZGluZyBvZiBmYWxzZS5cbiAgICogRmFsc2UgaXMgdGhlIHN0YXJ0IG9mIHRoZSBzZWNvbmQgaGFsZiBvZiAzMSBiaXRzXG4gICAqL1xuICBGQUxTRSA9IElNTUVESUFURV9MRU5HVEggLyAyLFxuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBpbnQgdGhhdCBjYW4gYmUgZGlyZWN0bHkgZW5jb2RlZCB2cyBhIGhhbmRsZS5cbiAgICpcbiAgICogVGhlIGxhc3QgcG9zaXRpdmUgaW50IGlzIGp1c3QgYmVmb3JlIEZBTFNFLlxuICAgKi9cbiAgTUFYX0lOVCA9IEZBTFNFIC0gMSxcblxuICAvKipcbiAgICogVGhlIGVuY29kaW5nIG9mIHRydWVcbiAgICovXG4gIFRSVUUgPSBGQUxTRSArIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBlbmNvZGluZyBvZiBudWxsXG4gICAqL1xuICBOVUxMID0gVFJVRSArIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBlbmNvZGluZyBvZiB1bmRlZmluZWRcbiAgICovXG4gIFVOREVGSU5FRCA9IE5VTEwgKyAxLFxuXG4gIC8qKlxuICAgKiBFbmNvZGVkIC0xXG4gICAqXG4gICAqIEVuY29kZWQganVzdCBhZnRlciBVTkRFRklORURcbiAgICovXG4gIE5FR0FUSVZFX09ORSA9IFVOREVGSU5FRCArIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIHRvIHN1YnN0cmFjdCBhIG5lZ2F0aXZlIGZyb20gdG8gZGVjb2RlIG9yIGVuY29kZSBpdC5cbiAgICpcbiAgICogTkVHQVRJVkVfT05FICAgICAgPT0gTkVHQVRJVkVfQkFTRSAtIC0xICAgICAgICAgICAgID09IGVuY29kZUltbWVkaWF0ZSgtMSlcbiAgICogTUFYX0lNTUVESUFURSAgICAgPT0gTkVHQVRJVkVfQkFTRSAtIE1JTl9JTlQgICAgICAgID09IGVuY29kZUltbWVkaWF0ZShNSU5fSU5UKVxuICAgKiAtMSAgICAgICAgICAgICAgICA9PSBORUdBVElWRV9CQVNFIC0gTkVHQVRJVkVfT05FICAgPT0gZGVjb2RlSW1tZWRpYXRlKE5FR0FUSVZFX09ORSlcbiAgICogTUlOX0lOVCAgICAgICAgICAgPT0gTkVHQVRJVkVfQkFTRSAtIE1BWF9JTU1FRElBVEUgID09IGRlY29kZUltbWVkaWF0ZShNQVhfSU1NRURJQVRFKVxuICAgKi9cbiAgTkVHQVRJVkVfQkFTRSA9IE5FR0FUSVZFX09ORSAtIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGludCB0aGF0IGNhbiBiZSBkaXJlY3RseSBlbmNvZGVkIHZzIGEgaGFuZGxlLlxuICAgKi9cbiAgTUlOX0lOVCA9IE5FR0FUSVZFX0JBU0UgLSBNQVhfSU1NRURJQVRFLFxufVxuXG4vKipcbiAqIFRoZSBjb21waWxlciBjb25zdGFudHMgZGl2aWRlIHRoZSBoYW5kbGVzIGludG8gdHdvIGhhbHZlcyBzdHJpbmdzIGFuZCBudW1iZXJzXG4gKiB3aGlsZSBvbiB0aGUgc3RhY2ssIHRoZXJlIGlzIG9ubHkgb25lIGFycmF5IG9mIGpzIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gSGFuZGxlQ29uc3RhbnRzIHtcbiAgSEFORExFX0xFTkdUSCA9IDIgKiogMzEsXG4gIE1BWF9JTkRFWCA9IEhBTkRMRV9MRU5HVEggLSAxLFxuICBNQVhfSEFORExFID0gLTEsXG4gIE1JTl9IQU5ETEUgPSAtMSAtIE1BWF9JTkRFWCxcbiAgU1RSSU5HX0hBTkRMRV9MRU5HVEggPSBIQU5ETEVfTEVOR1RIIC8gMixcbiAgTlVNQkVSX0hBTkRMRV9MRU5HVEggPSBIQU5ETEVfTEVOR1RIIC0gU1RSSU5HX0hBTkRMRV9MRU5HVEgsXG4gIFNUUklOR19NQVhfSU5ERVggPSBTVFJJTkdfSEFORExFX0xFTkdUSCAtIDEsXG4gIE5VTUJFUl9NQVhfSU5ERVggPSBOVU1CRVJfSEFORExFX0xFTkdUSCAtIDEsXG4gIFNUUklOR19NQVhfSEFORExFID0gTUFYX0hBTkRMRSxcbiAgU1RSSU5HX01JTl9IQU5ETEUgPSBTVFJJTkdfTUFYX0hBTkRMRSAtIFNUUklOR19NQVhfSU5ERVgsXG4gIE5VTUJFUl9NQVhfSEFORExFID0gU1RSSU5HX01JTl9IQU5ETEUgLSAxLFxuICBOVU1CRVJfTUlOX0hBTkRMRSA9IE5VTUJFUl9NQVhfSEFORExFIC0gTlVNQkVSX01BWF9JTkRFWCxcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgdmFsdWUgdGhhdCBjYW4gYmUgc3RvcmVkIGRpcmVjdGx5IGluc3RlYWQgb2YgYmVpbmcgYSBoYW5kbGUuXG4gKlxuICogSW1tZWRpYXRlcyB1c2UgdGhlIHBvc2l0aXZlIGhhbGYgb2YgMzJiaXRzXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVJbW1lZGlhdGUodmFsdWU6IG51bGwgfCB1bmRlZmluZWQgfCBib29sZWFuIHwgbnVtYmVyKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgICBjaGVja0ludCEodmFsdWUsIEltbWVkaWF0ZUNvbnN0YW50cy5NSU5fSU5ULCBJbW1lZGlhdGVDb25zdGFudHMuTUFYX0lOVCk7XG4gICAgfVxuICAgIC8vIG1hcCAtMSB0byAtMTA3Mzc0MTgyMCBvbnRvIDEwNzM3NDE4MjggdG8gMjE0NzQ4MzY0N1xuICAgIC8vIDEwNzM3NDE4MjcgLSAoLTEpID09IDEwNzM3NDE4MjhcbiAgICAvLyAxMDczNzQxODI3IC0gKC0xMDczNzQxODIwKSA9PSAyMTQ3NDgzNjQ3XG4gICAgLy8gcG9zaXRpdmUgaXQgc3RheXMgYXMgaXNcbiAgICAvLyAwIC0gMTA3Mzc0MTgyM1xuICAgIHJldHVybiB2YWx1ZSA8IDAgPyBJbW1lZGlhdGVDb25zdGFudHMuTkVHQVRJVkVfQkFTRSAtIHZhbHVlIDogdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBJbW1lZGlhdGVDb25zdGFudHMuRkFMU0U7XG4gIH1cbiAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIEltbWVkaWF0ZUNvbnN0YW50cy5UUlVFO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBJbW1lZGlhdGVDb25zdGFudHMuTlVMTDtcbiAgfVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBJbW1lZGlhdGVDb25zdGFudHMuVU5ERUZJTkVEO1xuICB9XG4gIHJldHVybiBleGhhdXN0ZWQodmFsdWUpO1xufVxuXG4vKipcbiAqIERlY29kZXMgYW4gaW1tZWRpYXRlIGludG8gaXRzIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBlbmNvZGVkIGltbWVkaWF0ZSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSW1tZWRpYXRlKHZhbHVlOiBudW1iZXIpOiBudWxsIHwgdW5kZWZpbmVkIHwgYm9vbGVhbiB8IG51bWJlciB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIC8vIGV4cGVjdGVkIHZhbHVlIHRvIGJlIGNoZWNrZWQgYmVmb3JlIHRoaXNcbiAgICBjaGVja0ludCEodmFsdWUsIEltbWVkaWF0ZUNvbnN0YW50cy5NSU5fSU1NRURJQVRFLCBJbW1lZGlhdGVDb25zdGFudHMuTUFYX0lNTUVESUFURSk7XG4gIH1cbiAgaWYgKHZhbHVlID4gSW1tZWRpYXRlQ29uc3RhbnRzLk1BWF9JTlQpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIEltbWVkaWF0ZUNvbnN0YW50cy5GQUxTRTpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY2FzZSBJbW1lZGlhdGVDb25zdGFudHMuVFJVRTpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIEltbWVkaWF0ZUNvbnN0YW50cy5OVUxMOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSW1tZWRpYXRlQ29uc3RhbnRzLlVOREVGSU5FRDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIG1hcCAxMDczNzQxODI4IHRvIDIxNDc0ODM2NDcgdG8gLTEgdG8gLTEwNzM3NDE4MjBcbiAgICAgICAgLy8gMTA3Mzc0MTgyNyAtIDEwNzM3NDE4MjggPT0gLTFcbiAgICAgICAgLy8gMTA3Mzc0MTgyNyAtIDIxNDc0ODM2NDcgPT0gLTEwNzM3NDE4MjBcbiAgICAgICAgcmV0dXJuIEltbWVkaWF0ZUNvbnN0YW50cy5ORUdBVElWRV9CQVNFIC0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBudW1iZXIgY2FuIGJlIHN0b3JlZCBkaXJlY3RseSBvciBmYWxzZSBpZiBpdCBuZWVkcyBhIGhhbmRsZS5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgb24gYW55IG51bWJlciB0eXBlIHRvIHNlZSBpZiBpdCBjYW4gYmUgZGlyZWN0bHkgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU21hbGxJbnQobnVtOiBudW1iZXIpIHtcbiAgcmV0dXJuIGlzSW50KG51bSwgSW1tZWRpYXRlQ29uc3RhbnRzLk1JTl9JTlQsIEltbWVkaWF0ZUNvbnN0YW50cy5NQVhfSU5UKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBlbmNvZGVkIGludDMyIG9wZXJhbmQgb3IgZW5jb2RlZCBzdGFjayBpbnQzMiBpcyBhIGhhbmRsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGFuZGxlKGVuY29kZWQ6IG51bWJlcikge1xuICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAvLyB3ZSBleHBlY3QgdG8gb25seSB1c2UgdGhpcyBtZXRob2Qgd2hlbiB3ZSBhbHJlYWR5IGtub3cgaXQgaXMgYW4gaW50MzJcbiAgICAvLyBiZWNhdXNlIGl0IHdhcyBlbmNvZGVkIG9yIHJlYWQgZnJvbSB0aGUgSW50MzJBcnJheSBidWZmZXJcbiAgICBjaGVja0ludCEoZW5jb2RlZCk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQgPCAwO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYW4gaW5kZXggdG8gYW4gb3BlcmFuZCBvciBzdGFjayBoYW5kbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVIYW5kbGUoXG4gIGluZGV4OiBudW1iZXIsXG4gIG1heEluZGV4OiBudW1iZXIgPSBIYW5kbGVDb25zdGFudHMuTUFYX0lOREVYLFxuICBtYXhIYW5kbGU6IG51bWJlciA9IEhhbmRsZUNvbnN0YW50cy5NQVhfSEFORExFXG4pIHtcbiAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgLy8gZXhwZWN0ZWQgdGhlIGluZGV4IHRvIGFscmVhZHkgYmUgYSBwb3NpdGl2ZSBpbnQgaW5kZXggZnJvbSBwdXNoaW5nIHRoZSB2YWx1ZVxuICAgIGNoZWNrSW50IShpbmRleCwgMCk7XG4gIH1cbiAgaWYgKGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGluZGV4ICR7aW5kZXh9IG92ZXJmbG93ZWQgcmFuZ2UgMCB0byAke21heEluZGV4fWApO1xuICB9XG4gIC8vIC0xIC0gMCA9PSAtMVxuICAvLyAtMSAtIDEwNzM3NDE4MjMgPT0gLTEwNzM3NDE4MjRcbiAgLy8gLTEwNzM3NDE4MjUgLSAwID09IC0xMDczNzQxODI1XG4gIC8vIC0xMDczNzQxODI1IC0gMTA3Mzc0MTgyMyA9PSAtMjE0NzQ4MzY0OFxuICByZXR1cm4gbWF4SGFuZGxlIC0gaW5kZXg7XG59XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgaW5kZXggZnJvbSB0aGUgc3BlY2lmaWVkIG9wZXJhbmQgb3Igc3RhY2sgaGFuZGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSGFuZGxlKGhhbmRsZTogbnVtYmVyLCBtYXhIYW5kbGU6IG51bWJlciA9IEhhbmRsZUNvbnN0YW50cy5NQVhfSEFORExFKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIC8vIHdlIGV4cGVjdCB0byBiZSBkZWNvZGluZyBhIGVuY29kZWQgaW50MzIgb3BlcmFuZCBvciBlbmNvZGVkIGludDMyIG9uIHRoZSBzdGFja1xuICAgIGNoZWNrSW50IShoYW5kbGUsIEhhbmRsZUNvbnN0YW50cy5NSU5fSEFORExFLCBtYXhIYW5kbGUpO1xuICB9XG4gIC8vIC0xIC0gLTEgPT0gMFxuICAvLyAtMSAtIC0xMDczNzQxODI0ID09IDEwNzM3NDE4MjNcbiAgLy8gLTEwNzM3NDE4MjUgLSAtMTA3Mzc0MTgyNSA9PSAwXG4gIC8vIC0xMDczNzQxODI1IC0gLTIxNDc0ODM2NDggPT0gMTA3Mzc0MTgyM1xuICByZXR1cm4gbWF4SGFuZGxlIC0gaGFuZGxlO1xufVxuXG5mdW5jdGlvbiBpc0ludChudW06IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgTWF0aC5mbG9vcihudW0pID09PSBudW1cbiAgLy8gYWxzbyBOYU4gJSAxIGlzIE5hTiBhbmQgSW5maW5pdHkgJSAxIGlzIE5hTiBzbyBib3RoIHNob3VsZCBmYWlsXG4gIHJldHVybiBudW0gJSAxID09PSAwICYmIG51bSA+PSBtaW4gJiYgbnVtIDw9IG1heDtcbn1cbiIsImltcG9ydCB7IEhhbmRsZVJlc3VsdCwgVGVtcGxhdGUsIFRlbXBsYXRlT2ssIE9rSGFuZGxlLCBFcnJIYW5kbGUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcEhhbmRsZShoYW5kbGU6IEhhbmRsZVJlc3VsdCk6IG51bWJlciB7XG4gIGlmICh0eXBlb2YgaGFuZGxlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBoYW5kbGU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGVycm9yID0gaGFuZGxlLmVycm9yc1swXTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGUgRXJyb3I6ICR7ZXJyb3IucHJvYmxlbX0gQCAke2Vycm9yLnNwYW4uc3RhcnR9Li4ke2Vycm9yLnNwYW4uZW5kfWApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBUZW1wbGF0ZTxNPih0ZW1wbGF0ZTogVGVtcGxhdGU8TT4pOiBUZW1wbGF0ZU9rPE0+IHtcbiAgaWYgKHRlbXBsYXRlLnJlc3VsdCA9PT0gJ2Vycm9yJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDb21waWxlIEVycm9yOiAke3RlbXBsYXRlLnByb2JsZW19IEAgJHt0ZW1wbGF0ZS5zcGFuLnN0YXJ0fS4uJHt0ZW1wbGF0ZS5zcGFuLmVuZH1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0ZW1wbGF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RIYW5kbGUoaGFuZGxlOiBIYW5kbGVSZXN1bHQpOiBudW1iZXIge1xuICBpZiAodHlwZW9mIGhhbmRsZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gaGFuZGxlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYW5kbGUuaGFuZGxlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09rSGFuZGxlKGhhbmRsZTogSGFuZGxlUmVzdWx0KTogaGFuZGxlIGlzIE9rSGFuZGxlIHtcbiAgcmV0dXJuIHR5cGVvZiBoYW5kbGUgPT09ICdudW1iZXInO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJIYW5kbGUoaGFuZGxlOiBIYW5kbGVSZXN1bHQpOiBoYW5kbGUgaXMgRXJySGFuZGxlIHtcbiAgcmV0dXJuIHR5cGVvZiBoYW5kbGUgPT09ICdudW1iZXInO1xufVxuIiwiaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuXG5sZXQgZGVidWdUb1N0cmluZzogdW5kZWZpbmVkIHwgKCh2YWx1ZTogdW5rbm93bikgPT4gc3RyaW5nKTtcblxuaWYgKERFQlVHKSB7XG4gIGxldCBnZXRGdW5jdGlvbk5hbWUgPSAoZm46IEZ1bmN0aW9uKSA9PiB7XG4gICAgbGV0IGZ1bmN0aW9uTmFtZSA9IGZuLm5hbWU7XG5cbiAgICBpZiAoZnVuY3Rpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBtYXRjaCA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZuKS5tYXRjaCgvZnVuY3Rpb24gKFxcdyspXFxzKlxcKC8pO1xuXG4gICAgICBmdW5jdGlvbk5hbWUgPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbk5hbWUucmVwbGFjZSgvXmJvdW5kIC8sICcnKTtcbiAgfTtcblxuICBsZXQgZ2V0T2JqZWN0TmFtZSA9IChvYmo6IG9iamVjdCkgPT4ge1xuICAgIGxldCBuYW1lO1xuICAgIGxldCBjbGFzc05hbWU7XG5cbiAgICBpZiAob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICBjbGFzc05hbWUgPSBnZXRGdW5jdGlvbk5hbWUob2JqLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAndG9TdHJpbmcnIGluIG9iaiAmJlxuICAgICAgb2JqLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICYmXG4gICAgICBvYmoudG9TdHJpbmcgIT09IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZ1xuICAgICkge1xuICAgICAgbmFtZSA9IG9iai50b1N0cmluZygpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBjbGFzcyBoYXMgYSBkZWNlbnQgbG9va2luZyBuYW1lLCBhbmQgdGhlIGB0b1N0cmluZ2AgaXMgb25lIG9mIHRoZVxuICAgIC8vIGRlZmF1bHQgRW1iZXIgdG9TdHJpbmdzLCByZXBsYWNlIHRoZSBjb25zdHJ1Y3RvciBwb3J0aW9uIG9mIHRoZSB0b1N0cmluZ1xuICAgIC8vIHdpdGggdGhlIGNsYXNzIG5hbWUuIFdlIGNoZWNrIHRoZSBsZW5ndGggb2YgdGhlIGNsYXNzIG5hbWUgdG8gcHJldmVudCBkb2luZ1xuICAgIC8vIHRoaXMgd2hlbiB0aGUgdmFsdWUgaXMgbWluaWZpZWQuXG4gICAgaWYgKFxuICAgICAgbmFtZSAmJlxuICAgICAgbmFtZS5tYXRjaCgvPC4qOmVtYmVyXFxkKz4vKSAmJlxuICAgICAgY2xhc3NOYW1lICYmXG4gICAgICBjbGFzc05hbWVbMF0gIT09ICdfJyAmJlxuICAgICAgY2xhc3NOYW1lLmxlbmd0aCA+IDIgJiZcbiAgICAgIGNsYXNzTmFtZSAhPT0gJ0NsYXNzJ1xuICAgICkge1xuICAgICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvPC4qOi8sIGA8JHtjbGFzc05hbWV9OmApO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lIHx8IGNsYXNzTmFtZTtcbiAgfTtcblxuICBsZXQgZ2V0UHJpbWl0aXZlTmFtZSA9ICh2YWx1ZTogYW55KSA9PiB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH07XG5cbiAgZGVidWdUb1N0cmluZyA9ICh2YWx1ZTogdW5rbm93bikgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBnZXRGdW5jdGlvbk5hbWUodmFsdWUpIHx8IGAodW5rbm93biBmdW5jdGlvbilgO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGdldE9iamVjdE5hbWUodmFsdWUpIHx8IGAodW5rbm93biBvYmplY3QpYDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldFByaW1pdGl2ZU5hbWUodmFsdWUpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVidWdUb1N0cmluZztcbiIsImV4cG9ydCB7IEVNUFRZX0FSUkFZIH0gZnJvbSAnLi9saWIvYXJyYXktdXRpbHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhc3NlcnQsIGRlcHJlY2F0ZSB9IGZyb20gJy4vbGliL2Fzc2VydCc7XG5leHBvcnQgeyBkaWN0LCBEaWN0U2V0LCBpc0RpY3QsIGlzT2JqZWN0LCBTZXQsIFN0YWNrSW1wbCBhcyBTdGFjayB9IGZyb20gJy4vbGliL2NvbGxlY3Rpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2RvbSc7XG5leHBvcnQgeyBlbnN1cmVHdWlkLCBIYXNHdWlkLCBpbml0aWFsaXplR3VpZCB9IGZyb20gJy4vbGliL2d1aWQnO1xuZXhwb3J0IHtcbiAgaXNTZXJpYWxpemF0aW9uRmlyc3ROb2RlLFxuICBTRVJJQUxJWkFUSU9OX0ZJUlNUX05PREVfU1RSSU5HLFxufSBmcm9tICcuL2xpYi9pcy1zZXJpYWxpemF0aW9uLWZpcnN0LW5vZGUnO1xuZXhwb3J0IHtcbiAgQ2xvbmVhYmxlTGlzdE5vZGUsXG4gIEVNUFRZX1NMSUNFLFxuICBMaW5rZWRMaXN0LFxuICBMaW5rZWRMaXN0Tm9kZSxcbiAgTGlzdE5vZGUsXG4gIExpc3RTbGljZSxcbiAgU2xpY2UsXG59IGZyb20gJy4vbGliL2xpc3QtdXRpbHMnO1xuZXhwb3J0IHsgYXNzaWduLCBmaWxsTnVsbHMsIHZhbHVlcyB9IGZyb20gJy4vbGliL29iamVjdC11dGlscyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9wbGF0Zm9ybS11dGlscyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9zdHJpbmcnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvaW1tZWRpYXRlJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL3RlbXBsYXRlJztcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBkZWJ1Z1RvU3RyaW5nIH0gZnJvbSAnLi9saWIvZGVidWctdG8tc3RyaW5nJztcblxuZXhwb3J0IHR5cGUgRklYTUU8VCwgUyBleHRlbmRzIHN0cmluZz4gPSAoVCAmIFMpIHwgVDtcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5ldmVyKHZhbHVlOiBuZXZlciwgZGVzYyA9ICd1bmV4cGVjdGVkIHVucmVhY2hhYmxlIGJyYW5jaCcpOiB2b2lkIHtcbiAgY29uc29sZS5sb2coJ3VucmVhY2hhYmxlJywgdmFsdWUpO1xuICBjb25zb2xlLnRyYWNlKGAke2Rlc2N9IDo6ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSAoJHt2YWx1ZX0pYCk7XG59XG4iXSwibmFtZXMiOlsiREVCVUciXSwibWFwcGluZ3MiOiI7O01BQWEsV0FBVyxHQUFVLE1BQU0sQ0FBTixNQUFBLENBQTNCLEVBQTJCOztFQ0FsQztFQUVBO0FBRUEsRUFBTSxTQUFBLFdBQUEsQ0FBQSxJQUFBLEVBQUEsR0FBQSxFQUE0QztFQUNoRDtFQUNBO0VBQ0E7RUFDQTtFQUVBLE1BQUksQ0FBSixJQUFBLEVBQVc7RUFDVCxVQUFNLElBQUEsS0FBQSxDQUFVLEdBQUcsSUFBbkIsbUJBQU0sQ0FBTjtFQUNEO0VBQ0Y7QUFFRCxFQUVNLFNBQUEsU0FBQSxDQUFBLElBQUEs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
